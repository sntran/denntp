import {
  StringReader,
  assert,
} from "./dev_deps.ts";

import { Response } from "./response.ts";
import { MultiLineResponseCodes } from "./model.ts";

Deno.test("Response", async (t) => {
   await t.step("status", async (t) => {
    await t.step("is anything passed to constructor",() => {
      for (let status = 100; status < 600; status++) {
        const response = new Response(new StringReader(""), { status });
        assert(response.status === status);
      }
    });
  });

  await t.step("body", async (t) => {
    await t.step("is empty from empty reader", async () => {
      const response = new Response(new StringReader(""));
      const body = await response.text();
      assert(!body);
    });

    await t.step("is empty with non multi-line status and any reader", async () => {
      const response = new Response(new StringReader("foobar"), {
        status: 200,
      });
      const body = await response.text();
      assert(!body);
    });

    await t.step("is empty with 211 status (generated by GROUP command) and any reader", async () => {
      const response = new Response(new StringReader("foobar"), {
        status: 211,
      });
      const body = await response.text();
      assert(!body);
    });

    await t.step("is empty from reader of single dot", async () => {
      for await (const status of MultiLineResponseCodes) {
        const response = new Response(new StringReader("."), { status });
        const body = await response.text();
        assert(!body);
      }
    });

    await t.step("is empty from reader of terminating line", async () => {
      for await (const status of MultiLineResponseCodes) {
        const response = new Response(new StringReader(".\r\n"), { status });
        const body = await response.text();
        assert(!body);
      }
    });

    await t.step("is full line from reader of line before terminating line", async () => {
      for await (const status of MultiLineResponseCodes) {
        const response = new Response(new StringReader("foobar\r\n.\r\n"), { status });
        const body = await response.text();
        assert(body === "foobar\r\n", `should have body of "foobar" instead of "${ body }"`);
      }
    });

    await t.step("undo dot-stuffing", async () => {
      for await (const status of MultiLineResponseCodes) {
        const response = new Response(new StringReader("..foobar\r\n.\r\n"), { status });
        const body = await response.text();
        assert(body === ".foobar\r\n", `should have body of ".foobar" instead of "${ body }"`);
      }
    });

    await t.step("is full line with 211 status (generated by LISTGROUP command) and special statusText", async () => {
      let response = new Response(new StringReader("foobar\r\n.\r\n"), {
        status: 211,
        statusText: "articles follow",
      });
      let body = await response.text();
      assert(body === "foobar\r\n", `should contain body if statusText has "follow" word`);

      response = new Response(new StringReader("foobar\r\n.\r\n"), {
        status: 211,
        statusText: "list below",
      });
      body = await response.text();
      assert(body === "foobar\r\n", `should contain body if statusText has "list" word`);
    });
  });
});
